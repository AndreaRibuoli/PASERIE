             PGM        PARM(&GIT_USER &PACKAGEN &GITTOKEN &DEVOPT &OMISSIBLE)
             DCLPRCOPT  LOG(*NO) ALWRTVSRC(*NO)
             COPYRIGHT  TEXT('Andrea Ribuoli © 2020 - PASERIE Installer')
             DCL        VAR(&GIT_USER)  TYPE(*CHAR) LEN(30)
             DCL        VAR(&PACKAGEN)  TYPE(*CHAR) LEN(10)
             DCL        VAR(&GITTOKEN)  TYPE(*CHAR) LEN(40)
             DCL        VAR(&DEVOPT)    TYPE(*CHAR) LEN(1)
             DCL        VAR(&OMISSIBLE) TYPE(*CHAR) LEN(1)
             DCL        VAR(&VERBOSE) TYPE(*CHAR) LEN(1)
             INCLUDE    SRCMBR(CURL_INCL)
             DCL        VAR(&FREE_PTR) TYPE(*PTR) ADDRESS(*NULL)
             DCL        VAR(&RET_LEN)  TYPE(*INT) STG(*BASED) LEN(8) BASPTR(&FREE_PTR)
             DCL        VAR(&TOTAL_LEN)  TYPE(*INT) STG(*DEFINED) LEN(4) DEFVAR(&RET_LEN 5)
             DCL        VAR(&BODY_LEN) TYPE(*INT)  LEN(4)
             DCL        VAR(&CURL_VRM) TYPE(*CHAR) LEN(6)
             DCL        VAR(&MAHIGHB) TYPE(*CHAR) STG(*DEFINED) LEN(1) DEFVAR(&CURL_VRM)
             DCL        VAR(&MALOWBY) TYPE(*CHAR) STG(*DEFINED) LEN(1) DEFVAR(&CURL_VRM 2)
             DCL        VAR(&MIHIGHB) TYPE(*CHAR) STG(*DEFINED) LEN(1) DEFVAR(&CURL_VRM 3)
             DCL        VAR(&MILOWBY) TYPE(*CHAR) STG(*DEFINED) LEN(1) DEFVAR(&CURL_VRM 4)
             DCL        VAR(&PAHIGHB) TYPE(*CHAR) STG(*DEFINED) LEN(1) DEFVAR(&CURL_VRM 5)
             DCL        VAR(&PALOWBY) TYPE(*CHAR) STG(*DEFINED) LEN(1) DEFVAR(&CURL_VRM 6)
             DCL        VAR(&MAJORI) TYPE(*INT)  STG(*DEFINED) LEN(2) DEFVAR(&CURL_VRM)
             DCL        VAR(&MINORI) TYPE(*INT)  STG(*DEFINED) LEN(2) DEFVAR(&CURL_VRM 3)
             DCL        VAR(&PATCHI) TYPE(*INT)  STG(*DEFINED) LEN(2) DEFVAR(&CURL_VRM 5)
             DCL        VAR(&MAJORA) TYPE(*CHAR) LEN(4)
             DCL        VAR(&MINORA) TYPE(*CHAR) LEN(4)
             DCL        VAR(&PATCHA) TYPE(*CHAR) LEN(4)
             DCL        VAR(&MSGDTA) TYPE(*CHAR) LEN(128)
             DCL        VAR(&CURSRCROW) TYPE(*CHAR) LEN(132)
             DCL        VAR(&SPOOL)  TYPE(*CHAR) LEN(6) VALUE(*NONE)
             DCL        VAR(&X15) TYPE(*CHAR) LEN(1) VALUE(X'15')
             DCL        VAR(&EXTRACT)  TYPE(*DEC)   LEN(5 0)
             CHGVAR     VAR(&VERBOSE) VALUE(&OMISSIBLE)
             MONMSG     MSGID(MCH3601) EXEC(CHGVAR VAR(&VERBOSE) VALUE('N'))
             IF         COND(&DEVOPT = 'B') THEN(DO)
             CHGVAR     VAR(&SPOOL) VALUE(*PRINT)
             CHGVAR     VAR(&DEVOPT) VALUE('N')
             ENDDO
             CALLPRC    PRC('QtqIconvOpen') PARM((&T_CODE) (&F_CODE)) RTNVAL(&CONVD)
             IF         COND(&CDRC = -1) THEN(DO)
             SNDPGMMSG  MSG('Application error with iconv')
             GOTO       CMDLBL(FINE)
             ENDDO
             CALLPRC    PRC('QtqIconvOpen') PARM((&T_CODEB) (&F_CODEB)) RTNVAL(&CONVB)
             IF         COND(&CDRCB = -1) THEN(DO)
             SNDPGMMSG  MSG('Application error with iconv')
             GOTO       CMDLBL(FINE)
             ENDDO
             CALLPRC    PRC('EASY_LOAD') PARM((&FUNCS_PTR))
             CALLPRC    PRC('Qp2malloc') PARM((&SIZEF *BYVAL) (&LOCAF) (*)) RTNVAL(&MEMF_P)
             CALLPRC    PRC('VERS_INFO') PARM((&FUNCS_PTR) (&LOCAF))
             CHGVAR     VAR(&INFOPU) VALUE(&NATIVF)
             CHGVAR     VAR(&MAHIGHB) VALUE(X'00')
             CHGVAR     VAR(&MIHIGHB) VALUE(X'00')
             CHGVAR     VAR(&PAHIGHB) VALUE(X'00')
             CHGVAR     VAR(&MALOWBY) VALUE(&MAJOR)
             CHGVAR     VAR(&MILOWBY) VALUE(&MINOR)
             CHGVAR     VAR(&PALOWBY) VALUE(&PATCH)
             CHGVAR     VAR(&MAJORA) VALUE(&MAJORI)
             CHGVAR     VAR(&MINORA) VALUE(&MINORI)
             CHGVAR     VAR(&PATCHA) VALUE(&PATCHI)
             CHGVAR     VAR(&AGENT) VALUE('curl/' *CAT &MAJORA *TCAT '.' *CAT &MINORA *TCAT '.' *CAT &PATCHA)
             CHGVAR     VAR(&AGENT) VALUE(&AGENT *TCAT &NL)
             CHGVAR     VAR(&HDR) VALUE(&HDRI *TCAT &NL)
             CALLPRC    PRC('Qp2malloc') PARM((&SIZED *BYVAL) (&LOCAD) (*)) RTNVAL(&MEMD_P)
             CHGVAR     VAR(&HDR_P) VALUE(%ADDRESS(&HDR))
             CHGVAR     VAR(&IN_BYTES) VALUE(&SIZED)
             CHGVAR     VAR(&OUT_BYTES) VALUE(&SIZED)
             CHGVAR     VAR(&MEMD_P2) VALUE(&MEMD_P)
             CALLPRC    PRC('iconv') PARM((&CONVD *BYVAL) (&HDR_P) (&IN_BYTES) (&MEMD_P2) (&OUT_BYTES)) RTNVAL(&RC)
             CHGVAR     VAR(&AUT) VALUE(&AUTI *TCAT ' ' *CAT &GITTOKEN *CAT &NL)
             CALLPRC    PRC('Qp2malloc') PARM((&SIZEE *BYVAL) (&LOCAE) (*)) RTNVAL(&MEME_P)
             CHGVAR     VAR(&AUT_P) VALUE(%ADDRESS(&AUT))
             CHGVAR     VAR(&IN_BYTES) VALUE(&SIZEE)
             CHGVAR     VAR(&OUT_BYTES) VALUE(&SIZEE)
             CHGVAR     VAR(&MEME_P2) VALUE(&MEME_P)
             CALLPRC    PRC('iconv') PARM((&CONVD *BYVAL) (&AUT_P) (&IN_BYTES) (&MEME_P2) (&OUT_BYTES)) RTNVAL(&RC)
             CHGVAR     VAR(&LOCAC) VALUE(0)
             CALLPRC    PRC('SLIST_APPE') PARM((&FUNCS_PTR) (&LOCAC) (&LOCAD))
             CALLPRC    PRC('SLIST_APPE') PARM((&FUNCS_PTR) (&LOCAC) (&LOCAE))
             CHGVAR     VAR(&PKG_LPTR) VALUE(%ADDRESS(&PKG_BLCK))
             CALLPRC    PRC('Qp2malloc') PARM((&SIZEB *BYVAL) (&LOCAB) (*)) RTNVAL(&MEMB_P)
             CALLPRC    PRC('CALL_BACK') PARM((&FUNCS_PTR) (&LOCAB) (&CBCK))
             CALLPRC    PRC('EASY_INIT') PARM((&FUNCS_PTR) (&CURL))
             CHGVAR     VAR(&OPT_CD) VALUE(10023) /* CURLOPT_HTTPHEADER */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&LOCAC) (&ERROR))
             IF         COND(&VERBOSE *EQ 'Y') THEN(DO)
             CHGVAR     VAR(&OPT_CD)  VALUE(41)   /* CURLOPT_VERBOSE 41 */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&ONVALUE) (&ERROR))
             ENDDO
             CHGVAR     VAR(&OPT_CD)  VALUE(52)   /* CURLOPT_FOLLOWLOCATION */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&ONVALUE) (&ERROR))
             CHGVAR     VAR(&OPT_CD) VALUE(20011)  /* CURLOPT_WRITEFUNCTION */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&CBCK) (&ERROR))
             CHGVAR     VAR(&OPT_CD)  VALUE(10001) /* CURLOPT_WRITEDATA */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&LOCAB) (&ERROR))
             /* */
             CALLPRC    PRC('Qp2malloc') PARM((&SIZEA *BYVAL) (&LOCAA) (*)) RTNVAL(&MEMA_P)
             CHGVAR     VAR(&AGENT_P) VALUE(%ADDRESS(&AGENT))
             CHGVAR     VAR(&IN_BYTES) VALUE(&SIZEA)
             CHGVAR     VAR(&OUT_BYTES) VALUE(&SIZEA)
             CHGVAR     VAR(&FREE_PTR) VALUE(&MEMA_P)
             CALLPRC    PRC('iconv') PARM((&CONVD *BYVAL) (&AGENT_P) (&IN_BYTES) (&MEMA_P) (&OUT_BYTES)) RTNVAL(&RC)
             CHGVAR     VAR(&OPT_CD) VALUE(10018) /* CURLOPT_USERAGENT  */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&LOCAA) (&ERROR))
             CALLPRC    PRC('Qp2free') PARM((&FREE_PTR *BYVAL)) RTNVAL(&RTCD)
             /* */
             CALLPRC    PRC('Qp2malloc') PARM((&SIZE *BYVAL) (&LOCA) (*)) RTNVAL(&MEM_P)
             CHGVAR     VAR(&URLI) +
                          VALUE('https://api.github.com/repos/' +
                          *CAT &GIT_USER *TCAT '/' *CAT &PACKAGEN +
                          *TCAT '/contents/GUIDANCE.TXT')
             CHGVAR     VAR(&URL) VALUE(&URLI *TCAT &NL)
             CHGVAR     VAR(&URL_P) VALUE(%ADDRESS(&URL))
             CHGVAR     VAR(&IN_BYTES) VALUE(&SIZE)
             CHGVAR     VAR(&OUT_BYTES) VALUE(&SIZE)
             CHGVAR     VAR(&FREE_PTR) VALUE(&MEM_P)
             CALLPRC    PRC('iconv') PARM((&CONVD *BYVAL) (&URL_P) (&IN_BYTES) (&MEM_P) (&OUT_BYTES)) RTNVAL(&RC)
             CHGVAR     VAR(&OPT_CD) VALUE(10002) /* CURLOPT_URL  10002 */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&LOCA) (&ERROR))
             /* */
             CALLPRC    PRC('EASY_PERFO') PARM((&FUNCS_PTR) (&CURL) (&ERROR))
             IF         COND(&ERROR *NE 0) THEN(DO)
             SNDPGMMSG  MSG('La chiamata a libcurl ha dato errore.')
             GOTO       CMDLBL(FINE)
             ENDDO
             /* by copying &NATIVE char(16) into &BFP we are actually setting &NATIVEP pointer */
             CHGVAR     VAR(&BFP) VALUE(&NATIVE)
             CHGVAR     VAR(&CURR_P) VALUE(&NATIVP)
             CHGVAR     VAR(&EPOS) VALUE(0)
 NEXT:       CHGVAR     VAR(&SPOS) VALUE(&EPOS + 1)
             CHGVAR     VAR(&EPOS) VALUE(%SCAN(&OA &HTML &SPOS))
             IF         COND(&EPOS *EQ 0) THEN(DO)
             GOTO       CMDLBL(SKIP)
             ENDDO
             CHGVAR     VAR(&LEN) VALUE(&EPOS - &SPOS)
             /* writing the linefeed is essential (i.e. converting &LEN plus 1) in order to */
             /* populate records of source file members                                     */
             CHGVAR     VAR(&IN_BYTES) VALUE(&LEN + 1)
             CHGVAR     VAR(&HTML_E) VALUE(' ')
             CHGVAR     VAR(&HTML_P) VALUE(%ADDRESS(&HTML_E))
             CHGVAR     VAR(&OUT_BYTES) VALUE(&MAXRECLEN)
             CALLPRC    PRC('iconv') PARM((&CONVB *BYVAL) (&CURR_P) (&IN_BYTES) (&HTML_P) (&OUT_BYTES)) RTNVAL(&RC)
             IF         COND(%SST(&HTML_E 1 1) *EQ &NL) THEN(GOTO CMDLBL(SKIP))
             IF         COND(%SST(&HTML_E 1 1) *EQ '{') THEN(DO)
             SNDPGMMSG  MSG('GUIDANCE.TXT non trovato')
             GOTO       CMDLBL(FINE)
             ENDDO
             CHGVAR     VAR(&RPOS) VALUE(%SCAN(&LINEFEED &HTML_E 1) -1)
             CHGVAR     VAR(%SST(&PKG_BLCK &CURPOS 90)) VALUE(%SST(&HTML_E 1 &RPOS))
             CHGVAR     VAR(&CURPOS) VALUE(&CURPOS + 91)
             CHGVAR     VAR(&TOTCNT) VALUE(&TOTCNT + 1)
             CHGVAR     VAR(&TMP_FILN) VALUE(%SST(&HTML_E 1 10))
             CRTSRCPF   FILE(QTEMP/&TMP_FILN) RCDLEN(132)
             MONMSG     MSGID(CPF0000)
             CHGVAR     VAR(&EPOS) VALUE(0)
             CHGVAR     VAR(&NATIVP) VALUE(&CURR_P)
             GOTO       CMDLBL(NEXT)
SKIP:
             CALLPRC    PRC('EASY_CLEAN') PARM((&FUNCS_PTR) (&CURL))
REPEAT_I:
             CALLPRC    PRC('Qp2malloc') PARM((&SIZEB *BYVAL) (&LOCAB) (*)) RTNVAL(&MEMB_P)
             CALLPRC    PRC('CALL_BACK') PARM((&FUNCS_PTR) (&LOCAB) (&CBCK))
             CALLPRC    PRC('EASY_INIT') PARM((&FUNCS_PTR) (&CURL))
             CHGVAR     VAR(&OPT_CD) VALUE(10023) /* CURLOPT_HTTPHEADER */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&LOCAC) (&ERROR))
             IF         COND(&VERBOSE *EQ 'Y') THEN(DO)
             CHGVAR     VAR(&OPT_CD)  VALUE(41)   /* CURLOPT_VERBOSE 41 */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&ONVALUE) (&ERROR))
             ENDDO
             CHGVAR     VAR(&OPT_CD)  VALUE(52)   /* CURLOPT_FOLLOWLOCATION */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&ONVALUE) (&ERROR))
             CHGVAR     VAR(&OPT_CD) VALUE(20011)  /* CURLOPT_WRITEFUNCTION */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&CBCK) (&ERROR))
             CHGVAR     VAR(&OPT_CD)  VALUE(10001) /* CURLOPT_WRITEDATA */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&LOCAB) (&ERROR))
             CALLPRC    PRC('Qp2malloc') PARM((&SIZEA *BYVAL) (&LOCAA) (*)) RTNVAL(&MEMA_P)
             CHGVAR     VAR(&AGENT_P) VALUE(%ADDRESS(&AGENT))
             CHGVAR     VAR(&IN_BYTES) VALUE(&SIZEA)
             CHGVAR     VAR(&OUT_BYTES) VALUE(&SIZEA)
             CALLPRC    PRC('iconv') PARM((&CONVD *BYVAL) (&AGENT_P) (&IN_BYTES) (&MEMA_P) (&OUT_BYTES)) RTNVAL(&RC)
             CHGVAR     VAR(&OPT_CD) VALUE(10018) /* CURLOPT_USERAGENT  */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&LOCAA) (&ERROR))
             /* similar to the logic used with GUIDANCE.TXT file */
             CALLPRC    PRC('Qp2malloc') PARM((&SIZE *BYVAL) (&LOCA) (*)) RTNVAL(&MEM_P)
             CHGVAR     VAR(&FILEPATH) VALUE('/QSYS.LIB/QTEMP.LIB/' *CAT &PKG_FILN +
                          *TCAT '.FILE/' *CAT &PKG_MBRN *TCAT '.MBR')
             CHGVAR     VAR(&URLI) +
                          VALUE('https://api.github.com/repos/' +
                          *CAT &GIT_USER *TCAT '/' *CAT &PACKAGEN +
                          *TCAT '/contents/' *CAT &PKG_FILN *TCAT '/' +
                          *CAT &PKG_MBRN *TCAT '.' *CAT &PKG_EXTN)
             CHGVAR     VAR(&URL) VALUE(&URLI *TCAT &NL)
             CHGVAR     VAR(&URL_P) VALUE(%ADDRESS(&URL))
             CHGVAR     VAR(&IN_BYTES) VALUE(&SIZE)
             CHGVAR     VAR(&OUT_BYTES) VALUE(&SIZE)
             CHGVAR     VAR(&FREE_PTR) VALUE(&MEM_P)
             CALLPRC    PRC('iconv') PARM((&CONVD *BYVAL) (&URL_P) (&IN_BYTES) (&MEM_P) (&OUT_BYTES)) RTNVAL(&RC)
             CHGVAR     VAR(&OPT_CD) VALUE(10002) /* CURLOPT_URL  10002 */
             CALLPRC    PRC('EASY_SETOP') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&LOCA) (&ERROR))
             /* */
             CALLPRC    PRC('EASY_PERFO') PARM((&FUNCS_PTR) (&CURL) (&ERROR))
             IF         COND(&ERROR *NE 0) THEN(DO)
             SNDPGMMSG MSG('La chiamata a libcurl ha dato errore.')
             GOTO       CMDLBL(FINE)
             ENDDO
             CHGVAR     VAR(&OPT_CD) VALUE(6291464) /* CURLINFO_SIZE_DOWNLOAD_T */
             CALLPRC    PRC('EASY_GINFO') PARM((&FUNCS_PTR) (&CURL) (&OPT_CD) (&LOCA) (&ERROR))
             CHGVAR     VAR(&BODY_LEN) VALUE(&RET_LEN)
             CALLPRC    PRC('Qp2free') PARM((&FREE_PTR *BYVAL)) RTNVAL(&RTCD)

             CHGVAR     VAR(&OFLAG) VALUE(&O_WRONLY + &O_CREAT + &O_TRUNC + &O_APPEND + &O_SYNC + &O_TEXTDATA)
             CALLPRC    PRC('open') PARM((&FILEPATH) (&OFLAG *BYVAL) (&MODE *BYVAL)) RTNVAL(&FD)
             /* by copying &NATIVE char(16) into &BFP we are actually setting &NATIVEP pointer */
             CHGVAR     VAR(&BFP) VALUE(&NATIVE)
             CHGVAR     VAR(&CURR_P) VALUE(&NATIVP)
         /*                                                                      */
         /*    scansiono &HTML (utf-8) cercando il primo 0x0a (new-line)         */
         /*      per farlo mi occorre partire dalla prima posizione (1)          */
         /*      sapendo che successivamente dovrò incrementare di 1 la          */
         /*      ultima posizione  elaborata: ecco perchè inizializzo &EPOS      */
         /*      a zero e memorizzo in &SPOS il suo valore incrementato di 1     */
         /*    quando non trovo il new-line chiudo il file                       */
         /*      questo tuttavia mi espone ad un errore nel caso tale            */
         /*      terminatore di riga manchi                                      */
         /*                                                                      */
         /*         &SPOS                                                        */
         /*       /              &EPOS = 7                                       */
         /*       |            /                                                 */
         /*       |            |                                                 */
         /*       v            v                                                 */
         /*      |E|N|D|P|G|M|0x0A|                                              */
         /*                                                                      */
         /*      poniamo &LEN=6 e &IN_BYTES=7                                    */
         /*                                                                      */
         /*      la conversione potrebbe ridurre il numero di byte necessari     */
         /*                                                                      */
         /*      Comprendo quanti siano stati dal valore di &HTML_P dopo         */
         /*      la esecuzione della iconv() rispetto a %ADDRESS(&HTML_E)        */
         /*                                                                      */
         /*                                                                      */
             CHGVAR     VAR(&EPOS) VALUE(0)
             CHGVAR     VAR(&OUT_BYTES) VALUE(&MAXRECLEN)
 NEXT_I:     CHGVAR     VAR(&SPOS) VALUE(&EPOS + 1)
             CHGVAR     VAR(&EPOS) VALUE(%SCAN(&OA &HTML &SPOS))
             IF         COND(&EPOS *EQ 0) THEN(DO)        /* No more LINE FEEDs */
              IF         COND(&BODY_LEN *GT 0) THEN(DO)             
            /*      CHGVAR     VAR(&HTML_E) VALUE(' ')                                                                */
            /* CHGVAR     VAR(&HTML_P) VALUE(%ADDRESS(&HTML_E))                                                       */
            /* CHGVAR     VAR(&PRE_BYTES) VALUE(&OUT_BYTES)                                                           */
            /* CALLPRC    PRC('iconv') PARM((&CONVB *BYVAL) (&CURR_P) (&BODY_LEN) (&HTML_P) (&OUT_BYTES)) RTNVAL(&RC) */
            /* IF         COND(%SST(&HTML_E 1 1) *EQ &NL) THEN(GOTO CMDLBL(SKIP_I))                                   */
            /* CHGVAR     VAR(&PRE_BYTES) VALUE(&PRE_BYTES - &OUT_BYTES)                                              */
            /* CALLPRC    PRC('write') PARM((&FD *BYVAL) (&HTML_E *BYREF) (&PRE_BYTES *BYVAL)) RTNVAL(&RTCD)          */
               DMPCLPGM
              ENDDO
              GOTO       CMDLBL(SKIP_I)
             ENDDO
             CHGVAR     VAR(&LEN) VALUE(&EPOS - &SPOS)
             CHGVAR     VAR(&IN_BYTES) VALUE(&LEN + 1)
             CHGVAR     VAR(&BODY_LEN) VALUE(&BODY_LEN - &IN_BYTES)
             CHGVAR     VAR(&HTML_E) VALUE(' ')
             CHGVAR     VAR(&HTML_P) VALUE(%ADDRESS(&HTML_E))
             CHGVAR     VAR(&PRE_BYTES) VALUE(&OUT_BYTES)
             CALLPRC    PRC('iconv') PARM((&CONVB *BYVAL) (&CURR_P) (&IN_BYTES) (&HTML_P) (&OUT_BYTES)) RTNVAL(&RC)
             IF         COND(%SST(&HTML_E 1 1) *EQ &NL) THEN(GOTO CMDLBL(SKIP_I))
             CHGVAR     VAR(&PRE_BYTES) VALUE(&PRE_BYTES - &OUT_BYTES)
             CALLPRC    PRC('write') PARM((&FD *BYVAL) (&HTML_E *BYREF) (&PRE_BYTES *BYVAL)) RTNVAL(&RTCD)
             CHGVAR     VAR(&EPOS) VALUE(0)
             CHGVAR     VAR(&NATIVP) VALUE(&CURR_P)
             GOTO       CMDLBL(NEXT_I)
 SKIP_I:     CALLPRC    PRC('close') PARM((&FD *BYVAL)) RTNVAL(&RTCD)
             CHGPFM     FILE(QTEMP/&PKG_FILN) MBR(&PKG_MBRN) SRCTYPE(&PKG_EXTN) TEXT(&PKG_TEXT)
             CALLPRC    PRC('EASY_CLEAN') PARM((&FUNCS_PTR) (&CURL))
             CHGVAR     VAR(%OFFSET(&PKG_LPTR)) VALUE(%OFFSET(&PKG_LPTR) + 91)
             CHGVAR     VAR(&COUNT) VALUE(&COUNT + 1)
             IF         COND(&COUNT *LT &TOTCNT) THEN(GOTO CMDLBL(REPEAT_I))
 CLOSE:      CALLPRC    PRC('Qp2dlclose') PARM((&IDC *BYVAL)) RTNVAL(&RTCD)
             IF         COND(&RTCD *NE 0) THEN(DO)
             CALLPRC    PRC('Qp2dlerror') RTNVAL(&ERR_P)
             IF         COND(&ERR_P *NE *NULL) THEN(SNDPGMMSG MSG(&MSG))
             ENDDO
             CALLPRC    PRC('Qp2dlclose') PARM((&ID *BYVAL)) RTNVAL(&RTCD)
             IF         COND(&RTCD *NE 0) THEN(DO)
             CALLPRC    PRC('Qp2dlerror') RTNVAL(&ERR_P)
             IF         COND(&ERR_P *NE *NULL) THEN(SNDPGMMSG MSG(&MSG))
             ENDDO
END:         CALLPRC    PRC('Qp2EndPase') RTNVAL(&RTCD)
             IF         COND(&RTCD *NE 0) THEN(SNDPGMMSG MSG('La chiamata Qp2EndPase ha dato errore.'))
             CRTBNDCL   PGM(QTEMP/BUILD) SRCFILE(QTEMP/QCLSRC) SRCMBR(BUILD) +
                        OUTPUT(&SPOOL) ALWRTVSRC(*NO)
             MONMSG     MSGID(CPF0000) EXEC(GOTO CMDLBL(PRVCLP))
             CALL       PGM(QTEMP/BUILD) PARM(&DEVOPT)
             MONMSG     MSGID(CPF0000)
             IF         COND(&VERBOSE *EQ 'L') THEN(DO)
             OVRDBF     FILE(STDOUT) TOFILE(QPRINT) OVRSCOPE(*JOB) SHARE(*YES)
             CHGVAR     VAR(&COUNT) VALUE(0)
             CHGVAR     VAR(&PKG_LPTR) VALUE(%ADDRESS(&PKG_BLCK))
             DOWHILE    COND(&COUNT *LT &TOTCNT)
             CHGVAR     VAR(&MSGDTA) VALUE( 'File: '      *CAT &PKG_FILN *CAT +
                                           ' Member: '    *CAT &PKG_MBRN *CAT +
                                           ' Attribute: ' *CAT &PKG_EXTN *CAT +
                                           ' Text: '      *CAT &PKG_TEXT *CAT &X15 *CAT &NL)
             CALLPRC    PRC('printf') PARM((&MSGDTA))
             CHGVAR     VAR(&COUNT) VALUE(&COUNT + 1)
             CHGVAR     VAR(%OFFSET(&PKG_LPTR)) VALUE(%OFFSET(&PKG_LPTR) + 91)
             ENDDO
             DLTOVR     FILE(STDOUT) LVL(*JOB)
             ENDDO
             GOTO       CMDLBL(FINE)
PRVCLP:      CRTCLPGM   PGM(QTEMP/BUILD) SRCFILE(QTEMP/QCLSRC) SRCMBR(BUILD) +
                        OUTPUT(&SPOOL) ALWRTVSRC(*NO) REPLACE(*NO)
             MONMSG     MSGID(CPF0000)
             CALL       PGM(QTEMP/BUILD) PARM(&DEVOPT)
             MONMSG     MSGID(CPF0000)
FINE:        ENDPGM
